### Zestaw Lekcji: Programowanie Obiektowe (OOP) w JavaScript

**Cel Ogólny:** Zrozumienie i praktyczne zastosowanie koncepcji programowania obiektowego w języku JavaScript.

---

### Lekcja 1: Wprowadzenie do Programowania Obiektowego (OOP) i Podstawowe Koncepcje

**1. Programowanie Obiektowe (OOP – Object-Oriented Programming)**
*   **Definicja:** Paradygmat programowania, który opiera się na koncepcji "obiektów" – struktur danych, które zawierają zarówno dane (właściwości/atrybuty), jak i kod (metody/funkcje), które operują na tych danych. Celem jest modelowanie świata rzeczywistego w kodzie.
*   **Wytłumaczenie:** Zamiast myśleć o programie jako o sekwencji instrukcji, myślimy o nim jako o zbiorze współpracujących ze sobą obiektów. Na przykład, w aplikacji bankowej możemy mieć obiekty `KontoBankowe`, `Klient`, `Transakcja`, które mają swoje dane i potrafią wykonywać określone działania.
*   **Zalety OOP:**
    *   **Reużywalność kodu:** Możemy tworzyć szablony (klasy) i używać ich wielokrotnie.
    *   **Łatwość utrzymania:** Kod jest bardziej zorganizowany i modularny, co ułatwia debugowanie i wprowadzanie zmian.
    *   **Skalowalność:** Prościej jest dodawać nowe funkcje i rozszerzać system.
    *   **Zrozumiałość:** Modelowanie świata rzeczywistego czyni kod bardziej intuicyjnym.

**2. Obiekt**
*   **Definicja:** Instancja klasy (lub samodzielna struktura w JS), która posiada własne dane (właściwości) i potrafi wykonywać określone działania (metody).
*   **Wytłumaczenie:** Myśl o obiekcie jak o konkretnym egzemplarzu czegoś. Na przykład, "mój telefon" to obiekt klasy `Telefon`, który ma konkretne właściwości (marka: Samsung, kolor: czarny, numer IMEI: XYZ) i potrafi wykonywać konkretne metody (dzwoń, wyślij SMS). W JavaScript często tworzymy obiekty bez formalnej klasy, np. za pomocą literału obiektu `{}`.

**3. Klasa (w ES6)**
*   **Definicja:** Szablon, plan lub schemat służący do tworzenia obiektów. Definiuje wspólne właściwości i metody, które będą miały wszystkie obiekty (instancje) utworzone na jej podstawie.
*   **Wytłumaczenie:** Jeśli obiekt to konkretny telefon, to klasa `Telefon` jest projektem, który mówi, że każdy telefon będzie miał markę, model i funkcje dzwonienia. Klasa sama w sobie nie jest obiektem, ale jest instrukcją do jego stworzenia.

**4. Właściwość (Atrybut)**
*   **Definicja:** Dana, cecha lub zmienna należąca do obiektu, która opisuje jego stan.
*   **Wytłumaczenie:** To są "rzeczy", które obiekt posiada. Dla obiektu `Samochod`, właściwościami mogą być `marka`, `model`, `kolor`, `rokProdukcji`.

**5. Metoda**
*   **Definicja:** Funkcja, która jest częścią obiektu (lub klasy) i wykonuje określone działanie związane z tym obiektem.
*   **Wytłumaczenie:** To są "działania", które obiekt potrafi wykonać. Dla obiektu `Samochod`, metodami mogą być `uruchom()`, `zatrzymaj()`, `przyspiesz()`.

**6. Konstruktor (`constructor`)**
*   **Definicja:** Specjalna metoda w klasie, która jest automatycznie wywoływana w momencie tworzenia nowego obiektu (instancji) tej klasy za pomocą słowa kluczowego `new`. Służy do inicjalizacji właściwości nowego obiektu.
*   **Wytłumaczenie:** To jest "instrukcja montażu" obiektu. Kiedy mówisz `new Samochod("Ford", "Focus")`, konstruktor `Samochod` bierze te wartości i przypisuje je do właściwości `marka` i `model` nowego obiektu.

**7. `this`**
*   **Definicja:** Słowo kluczowe w JavaScript, które odnosi się do "bieżącego obiektu", w kontekście którego funkcja lub metoda jest wywoływana. W kontekście klasy, `this` w metodach i konstruktorze odwołuje się do instancji klasy.
*   **Wytłumaczenie:** Kiedy w metodzie `uruchom()` piszesz `console.log(this.marka)`, `this` oznacza "ten konkretny samochód, na którym właśnie wywołano metodę `uruchom()`". Pozwala to odwołać się do właściwości danego obiektu, a nie innej instancji klasy.

**Czas trwania:** 45 minut

**Cele szczegółowe:**
*   Zdefiniowanie czym jest programowanie obiektowe.
*   Omówienie zalet OOP.
*   Wprowadzenie podstawowych terminów: obiekt, klasa (w kontekście ES6), właściwość, metoda.
*   Pokazanie, jak obiekty są wszędzie w JavaScript.

**Materiały:** Prezentacja, edytor kodu (np. VS Code), przeglądarka internetowa.

**Przebieg lekcji:**

1.  **Wstęp (5 min):**
    *   Czym jest programowanie obiektowe? Porównanie do programowania proceduralnego.
    *   Dlaczego warto uczyć się OOP? (Reużywalność kodu, łatwość utrzymania, skalowalność).
    *   Wspólne języki OOP (Java, C++, Python, C#) i miejsce JavaScript wśród nich.

2.  **Koncepcja Obiektu (10 min):**
    *   Obiekty jako "rzeczy" z własnymi cechami (właściwościami) i zachowaniami (metodami).
    *   Przykłady z życia wzięte (samochód, człowiek, telefon).
    *   Obiekty w JavaScript: dosłowny zapis obiektu (Object Literal).
        ```javascript
        const samochod = {
            marka: "Toyota",
            model: "Corolla",
            rokProdukcji: 2020,
            uruchom: function() {
                console.log("Samochód uruchomiony!");
            },
            zatrzymaj: function() {
                console.log("Samochód zatrzymany.");
            }
        };

        console.log(samochod.marka); // Dostęp do właściwości
        samochod.uruchom(); // Wywołanie metody
        ```

3.  **Właściwości i Metody (10 min):**
    *   **Właściwości:** Dane, które opisują obiekt (np. `marka`, `model`).
    *   **Metody:** Funkcje, które obiekt może wykonywać (np. `uruchom`, `zatrzymaj`).
    *   Ćwiczenie: Stwórz obiekt `osoba` z właściwościami (imię, wiek) i metodą `przedstawSie`.
        ```javascript
        const osoba = {
            imie: "Anna",
            wiek: 30,
            przedstawSie: function() {
                console.log(`Cześć, jestem ${this.imie} i mam ${this.wiek} lat.`);
            }
        };
        osoba.przedstawSie();
        ```

4.  **Wprowadzenie do Klas (ES6) (15 min):**
    *   Klasa jako "szablon" lub "plan" dla obiektów.
    *   Tworzenie klasy `Samochod` za pomocą składni ES6 `class`.
    *   Konstruktor (`constructor`) – specjalna metoda do inicjalizacji obiektu.
    *   Tworzenie instancji (obiektów) z klasy.
        ```javascript
        class Samochod {
            constructor(marka, model, rokProdukcji) {
                this.marka = marka;
                this.model = model;
                this.rokProdukcji = rokProdukcji;
            }

            uruchom() {
                console.log(`${this.marka} ${this.model} uruchomiony!`);
            }

            zatrzymaj() {
                console.log(`${this.marka} ${this.model} zatrzymany.`);
            }
        }

        const mojSamochod = new Samochod("Ford", "Focus", 2018);
        const twojSamochod = new Samochod("BMW", "X5", 2022);

        mojSamochod.uruchom();
        console.log(twojSamochod.rokProdukcji);
        ```
    *   Wyjaśnienie `this`.

5.  **Podsumowanie i Pytania (5 min):**
    *   Krótkie powtórzenie kluczowych pojęć.
    *   Odpowiedzi na pytania uczniów.

**Zadanie domowe:**
*   Stwórz klasę `Książka` z właściwościami (tytuł, autor, rok wydania) i metodą `wyswietlInfo`, która wypisze wszystkie informacje o książce. Stwórz dwie instancje tej klasy.

---

### Lekcja 2: Hermetyzacja i Enkapsulacja

**1. Hermetyzacja (Enkapsulacja)**
*   **Definicja:** Mechanizm OOP, który polega na ukrywaniu wewnętrznego stanu obiektu i ograniczaniu bezpośredniego dostępu do jego danych. Dostęp do danych odbywa się tylko za pośrednictwem publicznych metod obiektu.
*   **Wytłumaczenie:** Wyobraź sobie pilot do telewizora. Widzisz tylko przyciski (publiczne metody), ale nie widzisz skomplikowanej elektroniki w środku (prywatne dane). Hermetyzacja sprawia, że obiekt chroni swoje dane i pozwala na ich zmianę tylko w kontrolowany sposób, np. poprzez `gettery` i `settery`. Zapobiega to przypadkowym lub nieprawidłowym modyfikacjom danych.

**2. Właściwość Publiczna**
*   **Definicja:** Właściwość obiektu, do której można uzyskać bezpośredni dostęp i którą można modyfikować z zewnątrz obiektu.
*   **Wytłumaczenie:** W JavaScript domyślnie wszystkie właściwości są publiczne. Możesz do nich odwołać się bezpośrednio, np. `mojeKonto.saldo = 5000;`. Jest to proste, ale może prowadzić do błędów, jeśli nie chcemy, aby dane były zmieniane bez kontroli.

**3. Getter (Metoda dostępu)**
*   **Definicja:** Metoda (często specjalnie oznaczona słowem kluczowym `get`), która służy do kontrolowanego pobierania (odczytywania) wartości właściwości obiektu.
*   **Wytłumaczenie:** Zamiast bezpośrednio czytać `obiekt.wlasciwosc`, używasz `obiekt.getWlasciwosc()` lub `obiekt.wlasciwosc` (jeśli użyto `get` syntax). Pozwala to na dodanie logiki, np. formatowania danych przed ich zwróceniem.

**4. Setter (Metoda modyfikacji)**
*   **Definicja:** Metoda (często specjalnie oznaczona słowem kluczowym `set`), która służy do kontrolowanego ustawiania (modyfikowania) wartości właściwości obiektu. Często zawiera logikę walidacji danych.
*   **Wytłumaczenie:** Zamiast bezpośrednio zmieniać `obiekt.wlasciwosc = nowaWartosc;`, używasz `obiekt.setWlasciwosc(nowaWartosc)` lub `obiekt.wlasciwosc = nowaWartosc` (jeśli użyto `set` syntax). Setter pozwala sprawdzić, czy nowa wartość jest prawidłowa, zanim zostanie przypisana, np. czy saldo konta nie jest ujemne.

**5. Właściwości Prywatne (ES2022, `#` prefix)**
*   **Definicja:** Właściwości obiektu, które są dostępne wyłącznie z wnętrza klasy, w której zostały zdefiniowane. Nie można uzyskać do nich dostępu ani ich modyfikować bezpośrednio z zewnątrz obiektu.
*   **Wytłumaczenie:** Są to "naprawdę" prywatne dane. W JavaScript osiąga się to, poprzedzając nazwę właściwości znakiem `#` (hash). Dzięki temu, nawet przez pomyłkę, nie zmienisz ich z zewnątrz. To jest najsilniejsza forma hermetyzacji w JS.

**6. Konwencja `_` (underscore)**
*   **Definicja:** W JavaScript, właściwości poprzedzone pojedynczym podkreśleniem (np. `_saldo`) są konwencjonalnie traktowane jako "prywatne" lub "chronione". Nie są one faktycznie prywatne (można je zmienić z zewnątrz), ale deweloperzy zgadzają się, aby ich nie modyfikować bezpośrednio.
*   **Wytłumaczenie:** To jest sygnał dla innych programistów: "hej, ta właściwość jest przeznaczona do użytku wewnętrznego klasy, proszę nie zmieniaj jej bezpośrednio".

**Czas trwania:** 45 minut

**Cele szczegółowe:**
*   Zrozumienie pojęcia hermetyzacji (enkapsulacji).
*   Poznanie sposobów implementacji hermetyzacji w JavaScript (brak prawdziwego `private`, ale konwencje i alternatywy).
*   Wyjaśnienie gettery i settery.

**Materiały:** Edytor kodu, prezentacja.

**Przebieg lekcji:**

1.  **Wstęp (5 min):**
    *   Przypomnienie klasy i obiektu.
    *   Czym jest hermetyzacja? Dlaczego jest ważna? (Ukrywanie wewnętrznego stanu obiektu, kontrolowanie dostępu do danych, zapobieganie błędnym modyfikacjom).
    *   Metafora: pilot do telewizora (widzimy tylko przyciski, nie wiemy, jak działa w środku).

2.  **Właściwości Publiczne (10 min):**
    *   Domyślne właściwości w JavaScript są publiczne.
    *   Bezpośredni dostęp do właściwości z zewnątrz obiektu.
        ```javascript
        class KontoBankowe {
            constructor(wlasciciel, saldo) {
                this.wlasciciel = wlasciciel;
                this.saldo = saldo; // Publiczna właściwość
            }

            pokazSaldo() {
                console.log(`Saldo konta ${this.wlasciciel}: ${this.saldo} zł`);
            }
        }

        const mojeKonto = new KontoBankowe("Jan Kowalski", 1000);
        console.log(mojeKonto.saldo); // Bezpośredni dostęp
        mojeKonto.saldo = 5000; // Bezpośrednia modyfikacja - czy to dobrze?
        mojeKonto.pokazSaldo();
        ```
    *   Dyskusja: Jakie są problemy z bezpośrednią modyfikacją `saldo`? (Brak walidacji, łatwość wprowadzenia błędnych danych).

3.  **Gettery i Settery (15 min):**
    *   **Gettery:** Metody służące do pobierania wartości właściwości.
    *   **Settery:** Metody służące do ustawiania wartości właściwości, często z walidacją.
    *   Implementacja `get` i `set` w klasach ES6.
        ```javascript
        class KontoBankowe {
            constructor(wlasciciel, saldo) {
                this._wlasciciel = wlasciciel; // Konwencja: _ oznacza, że to jest "prywatne"
                this._saldo = saldo;
            }

            get wlasciciel() {
                return this._wlasciciel;
            }

            set wlasciciel(nowyWlasciciel) {
                if (typeof nowyWlasciciel === 'string' && nowyWlasciciel.length > 0) {
                    this._wlasciciel = nowyWlasciciel;
                } else {
                    console.error("Nieprawidłowe imię właściciela.");
                }
            }

            get saldo() {
                return this._saldo;
            }

            set saldo(noweSaldo) {
                if (typeof noweSaldo === 'number' && noweSaldo >= 0) {
                    this._saldo = noweSaldo;
                } else {
                    console.error("Nieprawidłowe saldo. Musi być liczbą nieujemną.");
                }
            }

            pokazSaldo() {
                console.log(`Saldo konta ${this._wlasciciel}: ${this._saldo} zł`);
            }

            wplac(kwota) {
                if (kwota > 0) {
                    this._saldo += kwota;
                    console.log(`Wpłacono ${kwota} zł. Nowe saldo: ${this._saldo} zł`);
                } else {
                    console.error("Kwota wpłaty musi być dodatnia.");
                }
            }
        }

        const mojeKonto2 = new KontoBankowe("Anna Nowak", 2000);
        console.log(mojeKonto2.wlasciciel); // Użycie gettera
        mojeKonto2.saldo = -100; // Użycie settera z walidacją
        mojeKonto2.wplac(500);
        mojeKonto2.saldo = 3000; // Poprawna zmiana
        mojeKonto2.pokazSaldo();
        ```

4.  **Właściwości Prywatne (ES2022) (10 min):**
    *   Krótkie omówienie prawdziwych właściwości prywatnych (prefix `#`).
    *   Wspomnienie, że to nowa funkcja i może nie być jeszcze powszechnie używana w starszych projektach.
        ```javascript
        class Osoba {
            #imie; // Prywatna właściwość
            #wiek;

            constructor(imie, wiek) {
                this.#imie = imie;
                this.#wiek = wiek;
            }

            get imie() {
                return this.#imie;
            }

            get wiek() {
                return this.#wiek;
            }

            przedstawSie() {
                console.log(`Cześć, jestem ${this.#imie} i mam ${this.#wiek} lat.`);
            }
        }

        const janek = new Osoba("Jan", 25);
        janek.przedstawSie();
        // console.log(janek.#imie); // Błąd! Nie można uzyskać dostępu
        ```
    *   Podkreślenie konwencji (`_` prefix) jako wciąż używanej praktyki.

5.  **Podsumowanie i Pytania (5 min):**
    *   Klucz do hermetyzacji: kontrolowany dostęp do danych.
    *   `get` i `set` jako podstawowe narzędzia.

**Zadanie domowe:**
*   Modyfikuj klasę `Książka` z poprzedniej lekcji. Dodaj gettery i settery dla tytułu i autora. Setter dla tytułu powinien sprawdzać, czy tytuł nie jest pustym stringiem. Setter dla roku wydania powinien sprawdzać, czy rok jest liczbą i jest większy niż 0.

---

### Lekcja 3: Dziedziczenie

**1. Dziedziczenie**
*   **Definicja:** Mechanizm OOP, który pozwala nowej klasie (klasie pochodnej/dziecko) przejąć właściwości i metody istniejącej klasy (klasy bazowej/rodzic), a następnie dodać własne, specyficzne cechy lub zmodyfikować odziedziczone.
*   **Wytłumaczenie:** To jak relacja "jest typem". `Pies jest-typem Zwierzęcia`. Pies dziedziczy podstawowe cechy zwierzęcia (ma nazwę, je), ale ma też swoje własne (szczeka, ma rasę). Dzięki temu nie musimy pisać tego samego kodu od nowa dla każdej klasy.

**2. Klasa Bazowa (Nadrzędna, Rodzic, Superklasa)**
*   **Definicja:** Klasa, z której inne klasy dziedziczą właściwości i metody.
*   **Wytłumaczenie:** To jest "ogólny plan". W przykładzie z zwierzętami, `Zwierze` jest klasą bazową.

**3. Klasa Pochodna (Podrzędna, Dziecko, Subklasa)**
*   **Definicja:** Klasa, która dziedziczy po klasie bazowej i może ją rozszerzać o nowe funkcjonalności lub modyfikować istniejące.
*   **Wytłumaczenie:** To jest "specjalizacja" ogólnego planu. `Pies` i `Kot` są klasami pochodnymi `Zwierze`.

**4. `extends`**
*   **Definicja:** Słowo kluczowe w JavaScript (ES6) używane do tworzenia relacji dziedziczenia. Używa się go w deklaracji klasy pochodnej, aby wskazać, z której klasy bazowej dziedziczy.
*   **Wytłumaczenie:** `class Pies extends Zwierze` oznacza "klasa `Pies` dziedziczy wszystko, co ma `Zwierze`".

**5. `super()`**
*   **Definicja:** Specjalne wywołanie w konstruktorze klasy pochodnej, które uruchamia konstruktor klasy bazowej. Musi być wywołane jako pierwsze w konstruktorze klasy pochodnej, jeśli klasa bazowa ma konstruktor.
*   **Wytłumaczenie:** Kiedy tworzysz `new Pies(...)`, musisz najpierw "zbudować" część `Zwierze` w `Pies`. `super()` to robi, przekazując niezbędne argumenty do konstruktora nadrzędnego, aby inicjalizować odziedziczone właściwości.

**6. Przesłanianie Metod (Overriding)**
*   **Definicja:** Proces, w którym klasa pochodna implementuje własną wersję metody, która została już zdefiniowana w jej klasie bazowej. Nowa implementacja zastępuje odziedziczoną.
*   **Wytłumaczenie:** Jeśli `Zwierze` ma metodę `wydajGlos()`, która tylko mówi "Zwierzę wydaje jakiś dźwięk", to `Pies` może *przesłonić* tę metodę i zamiast tego powiedzieć "Hau hau!". Klasa potomna ma wtedy swoją unikalną implementację metody.

**7. `super.metoda()`**
*   **Definicja:** W przesłoniętej metodzie klasy pochodnej, `super.metoda()` pozwala na wywołanie oryginalnej implementacji tej samej metody z klasy bazowej.
*   **Wytłumaczenie:** Czasami klasa pochodna chce zrobić coś *dodatkowo* do tego, co robi klasa nadrzędna. Na przykład, `Lew` ryczy, ale też chce najpierw powiedzieć "Zwierzę wydaje jakiś dźwięk" z klasy `Zwierze`, a potem dopiero "Rrrroaaarr!".


**Czas trwania:** 45 minut

**Cele szczegółowe:**
*   Zrozumienie pojęcia dziedziczenia w OOP.
*   Praktyczne zastosowanie dziedziczenia w JavaScript za pomocą słowa kluczowego `extends`.
*   Omówienie metody `super()`.
*   Zastosowanie przesłaniania (overriding) metod.

**Materiały:** Edytor kodu, prezentacja.

**Przebieg lekcji:**

1.  **Wstęp (5 min):**
    *   Przypomnienie klas.
    *   Czym jest dziedziczenie? (Kopiowanie cech i zachowań z klasy nadrzędnej do podrzędnej).
    *   Zalety dziedziczenia: reużywalność kodu, hierarchia klas, łatwiejsze zarządzanie.
    *   Metafora: rodzic i dziecko (dziecko dziedziczy pewne cechy po rodzicu, ale ma też swoje własne).

2.  **Klasy bazowe i pochodne (15 min):**
    *   Tworzenie klasy bazowej (nadrzędnej) `Zwierze`.
        ```javascript
        class Zwierze {
            constructor(nazwa) {
                this.nazwa = nazwa;
            }

            wydajGlos() {
                console.log("Zwierzę wydaje jakiś dźwięk.");
            }

            jedz() {
                console.log(`${this.nazwa} je.`);
            }
        }

        const ogolneZwierze = new Zwierze("Nieznane");
        ogolneZwierze.wydajGlos();
        ```
    *   Tworzenie klasy pochodnej (podrzędnej) `Pies` za pomocą `extends`.
    *   Użycie `super()` w konstruktorze klasy pochodnej do wywołania konstruktora klasy nadrzędnej.
        ```javascript
        class Pies extends Zwierze {
            constructor(nazwa, rasa) {
                super(nazwa); // Wywołuje constructor Zwierze(nazwa)
                this.rasa = rasa;
            }

            szczekaj() {
                console.log(`${this.nazwa} (${this.rasa}) szczeka: Hau hau!`);
            }
        }

        const reksio = new Pies("Reksio", "Owczarek Niemiecki");
        reksio.jedz(); // Metoda odziedziczona z Zwierze
        reksio.szczekaj(); // Metoda specyficzna dla Psa
        console.log(reksio.nazwa);
        console.log(reksio.rasa);
        ```

3.  **Przesłanianie Metod (Overriding) (15 min):**
    *   Sytuacja, gdy klasa pochodna ma własną implementację metody, która istnieje już w klasie bazowej.
    *   Przykład: `Pies` ma własną implementację `wydajGlos`.
        ```javascript
        class Kot extends Zwierze {
            constructor(nazwa, umaszczenie) {
                super(nazwa);
                this.umaszczenie = umaszczenie;
            }

            // Przesłanianie metody wydajGlos
            wydajGlos() {
                console.log(`${this.nazwa} (${this.umaszczenie}) miauczy: Miau!`);
            }

            drap() {
                console.log(`${this.nazwa} drapie.`);
            }
        }

        const mruczek = new Kot("Mruczek", "Czarny");
        mruczek.wydajGlos(); // Wywołuje przesłoniętą metodę z Kota
        mruczek.jedz(); // Metoda odziedziczona z Zwierze
        ```
    *   Użycie `super.metoda()` do wywołania oryginalnej metody z klasy bazowej wewnątrz przesłoniętej metody.
        ```javascript
        class Lew extends Zwierze {
            constructor(nazwa, waga) {
                super(nazwa);
                this.waga = waga;
            }

            wydajGlos() {
                super.wydajGlos(); // Wywołaj metodę wydajGlos z klasy Zwierze
                console.log(`${this.nazwa} ryczy: Rrroaaarr!`);
            }
        }

        const simba = new Lew("Simba", 180);
        simba.wydajGlos();
        ```

4.  **Złożone dziedziczenie (5 min):**
    *   Krótkie omówienie wielopoziomowego dziedziczenia (`class Dziecko extends Rodzic`, `class Rodzic extends Dziadek`).

5.  **Podsumowanie i Pytania (5 min):**
    *   Dziedziczenie to "jest-typem" relacji (Pies *jest* zwierzęciem).
    *   `extends` i `super` to kluczowe elementy.
    *   Reużywalność i hierarchia.

**Zadanie domowe:**
*   Stwórz klasę bazową `Pracownik` (imię, nazwisko, pensja).
*   Stwórz dwie klasy pochodne: `Programista` (dodatkowo: językProgramowania) i `Menedzer` (dodatkowo: dzial).
*   Każda klasa powinna mieć metodę `wyswietlInformacje`, która wyświetla dane pracownika.
*   Klasy pochodne powinny przesłonić `wyswietlInformacje` i dodać specyficzne dla siebie informacje, korzystając z `super.wyswietlInformacje()`.

---

### Lekcja 4: Polimorfizm

**1. Polimorfizm**
*   **Definicja:** Jeden z filarów OOP, oznaczający "wielopostaciowość". Pozwala traktować obiekty różnych klas w jednolity sposób, jeśli dziedziczą po wspólnej klasie bazowej lub implementują wspólny interfejs (w JavaScript to znaczy, że posiadają te same metody).
*   **Wytłumaczenie:** To zdolność obiektu do przyjmowania wielu form. Najczęściej oznacza to, że różne obiekty mogą reagować na to samo wywołanie metody (np. `wydajGlos()`) w różny, specyficzny dla siebie sposób, mimo że są traktowane jako obiekty wspólnego typu nadrzędnego. Dzięki temu kod jest bardziej elastyczny i rozszerzalny.

**2. Polimorfizm przez Dziedziczenie**
*   **Definicja:** Obiekty różnych klas pochodnych (np. `Pies`, `Kot`, `Kaczka`), które dziedziczą po wspólnej klasie bazowej (`Zwierze`) i przesłaniają jej metody (np. `wydajGlos()`), mogą być traktowane jako obiekty typu bazowego. Kiedy wywoływana jest przesłonięta metoda, JavaScript dynamicznie wybiera właściwą implementację dla danego obiektu.
*   **Wytłumaczenie:** Funkcja `sprawDzwieki(zwierze)` nie musi wiedzieć, czy dostaje `Psa`, `Kota` czy `Kaczkę`. Ważne jest tylko, że dostaje `Zwierze`, które potrafi `wydajGlos()`. System sam zdecyduje, które `wydajGlos()` wywołać, w zależności od rzeczywistego typu obiektu.

**3. "Duck Typing" (Kacze Typowanie)**
*   **Definicja:** Zasada w językach dynamicznych (jak JavaScript), która mówi: "Jeśli coś kwacze jak kaczka, pływa jak kaczka i chodzi jak kaczka, to jest kaczką". Oznacza to, że typ obiektu jest określany przez jego zachowanie (czyli przez to, jakie ma metody i właściwości), a nie przez formalną przynależność do klasy lub interfejsu.
*   **Wytłumaczenie:** W JavaScript nie potrzebujemy formalnych interfejsów. Jeśli obiekt ma metodę `przetworzPlatnosc()` i `zwrocStatus()`, to możemy go traktować jako obiekt obsługujący płatności, niezależnie od tego, czy jest to `PlatnoscKarta` czy `PlatnoscGotowka`. To daje dużą elastyczność.

**Czas trwania:** 45 minut

**Cele szczegółowe:**
*   Zrozumienie pojęcia polimorfizmu w OOP.
*   Praktyczne zastosowanie polimorfizmu w JavaScript.
*   Pokazanie, jak polimorfizm zwiększa elastyczność i rozszerzalność kodu.

**Materiały:** Edytor kodu, prezentacja.

**Przebieg lekcji:**

1.  **Wstęp (5 min):**
    *   Przypomnienie dziedziczenia i przesłaniania metod.
    *   Czym jest polimorfizm? (Wielopostaciowość – możliwość traktowania obiektów różnych klas jako obiekty tej samej klasy nadrzędnej, jeśli dziedziczą po niej).
    *   Zalety polimorfizmu: elastyczność, rozszerzalność, uproszczenie kodu.
    *   Metafora: "przycisk play" – działa na odtwarzaczu MP3, DVD, YouTube, choć każdy obiekt jest inny.

2.  **Polimorfizm przez dziedziczenie (20 min):**
    *   Wykorzystanie przykładu z lekcji 3 (Zwierzęta).
    *   Tworzenie funkcji, która przyjmuje obiekt klasy nadrzędnej i wywołuje na nim metodę, która jest przesłonięta w klasach pochodnych.
        ```javascript
        class Zwierze {
            constructor(nazwa) {
                this.nazwa = nazwa;
            }

            wydajGlos() {
                console.log("Zwierzę wydaje jakiś dźwięk.");
            }
        }

        class Pies extends Zwierze {
            constructor(nazwa) {
                super(nazwa);
            }
            wydajGlos() {
                console.log(`${this.nazwa} szczeka: Hau hau!`);
            }
        }

        class Kot extends Zwierze {
            constructor(nazwa) {
                super(nazwa);
            }
            wydajGlos() {
                console.log(`${this.nazwa} miauczy: Miau!`);
            }
        }

        class Kaczka extends Zwierze {
            constructor(nazwa) {
                super(nazwa);
            }
            wydajGlos() {
                console.log(`${this.nazwa} kwacze: Kwa kwa!`);
            }
        }

        // Funkcja przyjmująca obiekt Zwierze
        function sprawDzwieki(zwierze) {
            zwierze.wydajGlos(); // Ta sama metoda, różne zachowania!
        }

        const bonifacy = new Pies("Bonifacy");
        const puszek = new Kot("Puszek");
        const dziwaczek = new Kaczka("Dziwaczek");
        const nieznane = new Zwierze("Nieznane");

        sprawDzwieki(bonifacy);  // Wywołuje Pies.wydajGlos()
        sprawDzwieki(puszek);   // Wywołuje Kot.wydajGlos()
        sprawDzwieki(dziwaczek); // Wywołuje Kaczka.wydajGlos()
        sprawDzwieki(nieznane); // Wywołuje Zwierze.wydajGlos()

        // Przykład z tablicą obiektów
        const farma = [bonifacy, puszek, dziwaczek, new Pies("Burek"), new Kot("Filemon")];

        console.log("\nOdgłosy z farmy:");
        farma.forEach(zwierze => zwierze.wydajGlos());
        ```
    *   Wyjaśnienie, dlaczego to jest polimorfizm: pomimo, że funkcja `sprawDzwieki` oczekuje obiektu `Zwierze`, potrafi poprawnie obsłużyć obiekty pochodne, wywołując ich specyficzne implementacje metody `wydajGlos`.

3.  **Polimorfizm a interfejsy (konceptualnie) (10 min):**
    *   JavaScript nie ma wbudowanych interfejsów, ale możemy osiągnąć podobny efekt poprzez "duck typing" (jeśli coś kwacze jak kaczka i pływa jak kaczka, to jest kaczką).
    *   Chodzi o to, że obiekt musi implementować pewne metody, a niekoniecznie dziedziczyć z konkretnej klasy.
    *   Przykład: system płatności.
        ```javascript
        // Konceptualnie "interfejs" Płatność
        // Musi mieć metody: przetworzPlatnosc(kwota) i zwrocStatus()

        class PlatnoscKarta {
            przetworzPlatnosc(kwota) {
                console.log(`Przetwarzam płatność kartą na kwotę ${kwota} zł.`);
                // ... logika płatności kartą
                return true;
            }
            zwrocStatus() {
                return "Płatność kartą zakończona sukcesem.";
            }
        }

        class PlatnoscGotowka {
            przetworzPlatnosc(kwota) {
                console.log(`Przyjmuję gotówkę na kwotę ${kwota} zł.`);
                // ... logika płatności gotówką
                return true;
            }
            zwrocStatus() {
                return "Płatność gotówką zakończona sukcesem.";
            }
        }

        function wykonajTransakcje(sposobPlatnosci, kwota) {
            if (sposobPlatnosci.przetworzPlatnosc(kwota)) {
                console.log(sposobPlatnosci.zwrocStatus());
            } else {
                console.log("Transakcja nieudana.");
            }
        }

        const karta = new PlatnoscKarta();
        const gotowka = new PlatnoscGotowka();

        wykonajTransakcje(karta, 150);
        wykonajTransakcje(gotowka, 75);
        ```

4.  **Podsumowanie i Pytania (10 min):**
    *   Polimorfizm to elastyczność w traktowaniu obiektów.
    *   "Jedna metoda, wiele form".
    *   Kluczowy dla rozszerzalnych i łatwych do modyfikacji systemów.
    *   Cztery filary OOP: hermetyzacja, dziedziczenie, abstrakcja (częściowo omawiana, ale można wspomnieć), polimorfizm.

**Zadanie domowe:**
*   Zaprojektuj system do rysowania różnych figur geometrycznych.
*   Stwórz klasę bazową `Figura` z metodą `rysuj()`.
*   Stwórz klasy pochodne `Kwadrat`, `Kolo`, `Trojkat`, które przesłonią metodę `rysuj()` i wypiszą na konsoli, że rysują konkretną figurę.
*   Napisz funkcję `rysujWszystkieFigury(figury)`, która przyjmie tablicę obiektów `Figura` i dla każdej z nich wywoła metodę `rysuj()`.
*   Stwórz kilka instancji różnych figur i przekaż je do funkcji `rysujWszystkieFigury`.
    *   **Podpowiedź**: Klasa `Figura` może mieć również właściwości takie jak kolor czy rozmiar, które będą dziedziczone.
    
---

### Lekcja 5: Abstrakcja i Projektowanie Klas

**1. Abstrakcja**
*   **Definicja:** Jeden z filarów OOP, polegający na koncentrowaniu się na istotnych cechach obiektu, ukrywając jednocześnie skomplikowane szczegóły implementacji. Upraszcza modelowanie rzeczywistości, przedstawiając tylko te informacje, które są istotne dla użytkownika danego obiektu.
*   **Wytłumaczenie:** To jak obsługa samochodu – wiesz, jak włączyć silnik, wcisnąć gaz, hamulec, zmienić bieg. Te elementy są abstrakcją – pokazują tylko to, co potrzebujesz do interakcji. Nie musisz rozumieć skomplikowanych mechanizmów silnika, elektroniki czy skrzyni biegów, aby jechać.

**2. Klasa Abstrakcyjna (konceptualnie w JS)**
*   **Definicja:** Klasa, która jest przeznaczona do bycia klasą bazową dla innych klas, ale sama nie powinna być instancjonowana (nie można tworzyć jej bezpośrednich obiektów). Często definiuje metody abstrakcyjne, które muszą być zaimplementowane przez klasy pochodne.
*   **Wytłumaczenie:** W JavaScript nie ma słowa kluczowego `abstract`. Symulujemy to, sprawdzając w konstruktorze, czy `new.target` odnosi się do samej klasy abstrakcyjnej. Jeśli tak, zgłaszamy błąd. Klasa taka działa jako wspólny interfejs i zapewnia, że klasy pochodne będą miały określone funkcjonalności.

**3. Single Responsibility Principle (SRP) – Zasada Jednej Odpowiedzialności**
*   **Definicja:** Zasada projektowania oprogramowania, która mówi, że każda klasa (lub moduł, funkcja) powinna mieć tylko jeden powód do zmiany. Innymi słowy, klasa powinna mieć tylko jedną odpowiedzialność.
*   **Wytłumaczenie:** Jeśli klasa `Uzytkownik` zajmuje się zarówno zarządzaniem danymi użytkownika, wysyłaniem e-maili *i* komunikacją z bazą danych, to jest to zła praktyka. Jeśli zmieni się sposób wysyłania e-maili, musisz zmieniać klasę `Uzytkownik`. Lepiej, aby każda z tych odpowiedzialności była w osobnej klasie (np. `UserManager`, `EmailSender`, `DatabaseConnector`).

**4. Kompozycja (`HAS-A`)**
*   **Definicja:** Relacja między obiektami, w której jeden obiekt ("całość") zawiera w sobie inny obiekt ("część"). Obiekt "całość" *ma* obiekt "część".
*   **Wytłumaczenie:** Zamiast dziedziczyć, obiekt wykorzystuje funkcjonalności innego obiektu, "posiadając" go jako swoją właściwość. Np. `Samochod HAS-A Silnik`. Samochód nie *jest* silnikiem (dziedziczenie), ale *ma* silnik, który wykonuje pewne zadania. Kompozycja zazwyczaj prowadzi do bardziej elastycznego i luźno powiązanego kodu niż dziedziczenie.

**5. Dziedziczenie (`IS-A`)**
*   **Definicja:** Relacja, w której jeden obiekt *jest typem* innego obiektu (np. `Pies IS-A Zwierze`). Odbywa się to poprzez rozszerzanie klasy bazowej.
*   **Wytłumaczenie:** Gdy klasa `A` rozszerza klasę `B`, oznacza to, że `A` jest szczególnym rodzajem `B`.


**Czas trwania:** 45 minut

**Cele szczegółowe:**
*   Zrozumienie pojęcia abstrakcji w OOP.
*   Nauka projektowania klas (co powinno być właściwością, co metodą).
*   Kiedy używać dziedziczenia, a kiedy kompozycji.
*   Wskazówki do pisania czystego kodu obiektowego w JS.

**Materiały:** Edytor kodu, prezentacja, tablica (wirtualna lub fizyczna) do rysowania schematów.

**Przebieg lekcji:**

1.  **Wstęp (5 min):**
    *   Przypomnienie czterech filarów OOP.
    *   Czym jest abstrakcja? (Skupianie się na istotnych cechach, ignorowanie nieistotnych szczegółów).
    *   Przykład: samochód – wiemy jak jeździć (abstrakcja), nie musimy znać szczegółów działania silnika.
    *   Abstrakcja pomaga zarządzać złożonością.

2.  **Abstrakcja w Klasach (15 min):**
    *   **Klasy abstrakcyjne (konceptualnie w JS):** JavaScript nie ma wbudowanych klas abstrakcyjnych (takich jak np. w Javie czy C#). Możemy jednak symulować ich zachowanie.
    *   Klasa bazowa, która nie powinna być instancjonowana bezpośrednio. Metody, które muszą być zaimplementowane przez klasy pochodne.
        ```javascript
        class FiguraGeometryczna { // Klasa abstrakcyjna (konceptualnie)
            constructor() {
                if (new.target === FiguraGeometryczna) { // Zapobieganie instancjonowaniu
                    throw new Error("Nie można utworzyć instancji klasy abstrakcyjnej FiguraGeometryczna.");
                }
            }

            // Metoda abstrakcyjna (musi być zaimplementowana przez klasy pochodne)
            obliczPole() {
                throw new Error("Metoda 'obliczPole()' musi być zaimplementowana w klasie pochodnej.");
            }

            wyswietlTyp() {
                console.log("Jestem figurą geometryczną.");
            }
        }

        class Kwadrat extends FiguraGeometryczna {
            constructor(bok) {
                super();
                this.bok = bok;
            }
            obliczPole() {
                return this.bok * this.bok;
            }
            wyswietlTyp() {
                console.log("Jestem kwadratem.");
            }
        }

        // const figura = new FiguraGeometryczna(); // Błąd!
        const kwadrat = new Kwadrat(5);
        console.log(`Pole kwadratu: ${kwadrat.obliczPole()}`);
        kwadrat.wyswietlTyp();
        ```
    *   Dyskusja na temat tego, jak abstrakcja upraszcza interfejs użytkownika do obiektu.

3.  **Projektowanie Klas – Dobre Praktyki (15 min):**
    *   **Single Responsibility Principle (SRP):** Klasa powinna mieć tylko jeden powód do zmiany. (Np. klasa `User` nie powinna zajmować się wysyłaniem e-maili i zapisem do bazy danych).
    *   **Co jest właściwością, co metodą?**
        *   Właściwości: Stany obiektu (rzeczowniki).
        *   Metody: Zachowania obiektu (czasowniki).
    *   **Kompozycja vs. Dziedziczenie (HAS-A vs IS-A):**
        *   **Dziedziczenie (IS-A):** Gdy jeden obiekt *jest typem* innego (np. `Pies IS-A Zwierze`).
        *   **Kompozycja (HAS-A):** Gdy jeden obiekt *ma* inny obiekt (np. `Samochod HAS-A Silnik`).
        *   Kiedy używać kompozycji:
            ```javascript
            class Silnik {
                start() {
                    console.log("Silnik uruchomiony.");
                }
                stop() {
                    console.log("Silnik zatrzymany.");
                }
            }

            class Samochod {
                constructor(marka) {
                    this.marka = marka;
                    this.silnik = new Silnik(); // Kompozycja: Samochód MA Silnik
                }
                uruchom() {
                    console.log(`Samochód ${this.marka} próbuje uruchomić.`);
                    this.silnik.start();
                }
                zatrzymaj() {
                    console.log(`Samochód ${this.marka} próbuje zatrzymać.`);
                    this.silnik.stop();
                }
            }

            const nowySamochod = new Samochod("Volvo");
            nowySamochod.uruchom();
            ```
    *   **Zalety kompozycji:** Większa elastyczność, unikanie problemu "diamentu" w językach z wielokrotnym dziedziczeniem (choć w JS to nie problem bezpośrednio), luźne powiązanie.

4.  **Podsumowanie i Pytania (10 min):**
    *   Abstrakcja to uproszczenie złożoności.
    *   Dobre projektowanie klas jest kluczowe dla czystego i skalowalnego kodu.
    *   Pamiętaj o SRP, kiedy wybierać właściwość/metodę i kiedy kompozycję/dziedziczenie.
    *   Przykłady zastosowań OOP w JavaScript (React Components, Node.js modules, biblioteki).

**Zadanie domowe:**
*   Zaprojektuj system zarządzania biblioteką.
    *   Stwórz klasy: `Ksiazka`, `Autor`, `Uzytkownik`, `Biblioteka`.
    *   Zastanów się, jakie powinny być właściwości i metody dla każdej klasy.
    *   Zaimplementuj co najmniej jedną relację dziedziczenia i jedną kompozycji (np. `Biblioteka` ma wiele `Ksiazek`).
    *   Zadbaj o gettery i settery tam, gdzie to ma sens, aby zapewnić hermetyzację.
    *   W `Bibliotece` zaimplementuj metody takie jak `dodajKsiazke`, `wypozyczKsiazke`, `zwrocKsiazke`, `wyswietlDostepneKsiazki`.

---

***Projekt Końcowy (Opcjonalny, do realizacji po wszystkich lekcjach):**

**Cel:** Zastosowanie wszystkich poznanych koncepcji OOP w JavaScript do stworzenia małej aplikacji.

**Scenariusz:** System do zarządzania zamówieniami w restauracji.

**Wymagane klasy:**
*   `Produkt` (nazwa, cena, kategoria)
*   `Danie` (rozszerza `Produkt`, dodaje składniki)
*   `Napoj` (rozszerza `Produkt`, dodaje pojemnosc)
*   `Zamowienie` (lista produktów, status, suma całkowita, metody: `dodajProdukt`, `usunProdukt`, `obliczSume`, `zmienStatus`)
*   `Klient` (imię, adres, lista zamówień, metody: `zlozZamowienie`, `wyswietlHistorieZamowien`)
*   `Restauracja` (nazwa, menu (tablica `Produktów`), lista zamówień, metody: `dodajDoMenu`, `przyjmijZamowienie`, `zrealizujZamowienie`, `wyswietlMenu`).

**Wymagania:**
*   Użycie klas, konstruktorów.
*   Dziedziczenie (`Danie` i `Napoj` dziedziczą po `Produkt`).
*   Hermetyzacja (gettery/settery, konwencje prywatności).
*   Polimorfizm (np. w metodzie `obliczSume` w `Zamowienie`, która działa na różnych typach `Produktów`).
*   Abstrakcja (projektowanie interfejsów klas).
*   Zastosowanie kompozycji (np. `Zamowienie` zawiera listę `Produktów`).
*   Proste interakcje na konsoli.

